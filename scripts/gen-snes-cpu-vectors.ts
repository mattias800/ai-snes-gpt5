import * as fs from 'fs';
import * as path from 'path';
import { parseCpuVectors, discoverCpuTestsRoot } from '../src/third_party/snesTests/parseCpuVectors';
import type { CpuVector } from '../src/third_party/snesTests/types';

const projectRoot = path.resolve('.');
const DEFAULT_ROOT = path.resolve(projectRoot, 'test-roms/snes-tests');
const SNES_TESTS_DIR = process.env.SNES_TESTS_DIR || DEFAULT_ROOT;

function esc(s: string): string { return JSON.stringify(s); }

function emitOperands(v: CpuVector): string {
  const parts: string[] = [];
  if (v.operands.imm !== undefined) parts.push(`imm: ${v.operands.imm}`);
  if (v.operands.dp !== undefined) parts.push(`dp: ${v.operands.dp}`);
  if (v.operands.abs !== undefined) parts.push(`abs: ${v.operands.abs}`);
  if (v.operands.long !== undefined) parts.push(`long: ${v.operands.long}`);
  if (v.operands.sr !== undefined) parts.push(`sr: ${v.operands.sr}`);
  return `{ ${parts.join(', ')} }`;
}

function emitRegs<K extends keyof CpuVector['input']>(obj: Partial<CpuVector['input']>, keys: K[]): string {
  const parts: string[] = [];
  for (const k of keys) {
    const v = obj[k];
    if (v !== undefined) parts.push(`${k}: ${v}`);
  }
  return `{ ${parts.join(', ')} }`;
}

function emitExpected(obj: CpuVector['expected']): string {
  const keys: (keyof CpuVector['expected'])[] = ['A','X','Y','P','E','S','D','DBR'];
  const parts: string[] = [];
  for (const k of keys) {
    const v = obj[k];
    if (v !== undefined) parts.push(`${k}: ${v}`);
  }
  return `{ ${parts.join(', ')} }`;
}

function emitMem(arr: { addr24: number; val: number }[]): string {
  if (arr.length === 0) return '[]';
  return `[
${arr.map(m => `  { addr24: ${m.addr24 >>> 0}, val: ${m.val & 0xff} }`).join(',\n')}
]`;
}

function emitVector(v: CpuVector): string {
  const base = [
    `id: ${v.id >>> 0}`,
    `idHex: ${esc(v.idHex)}`,
    `insDisplay: ${esc(v.insDisplay)}`,
    `op: ${esc(v.op)}`,
    `mode: ${esc(v.mode)}`,
    `operands: ${emitOperands(v)}`,
    `input: ${emitRegs(v.input, ['A','X','Y','P','E','S','D','DBR'])}`,
    `memInit: ${emitMem(v.memInit)}`,
    `expected: ${emitExpected(v.expected)}`,
    `memExpect: ${emitMem(v.memExpect)}`,
    `requiresScaffolding: ${v.requiresScaffolding ? 'true' : 'false'}`,
  ];
  if (v.note) base.push(`note: ${esc(v.note)}`);
  return `{
  ${base.join(',\n  ')}
}`;
}

function makeTestFile(vectors: CpuVector[], outPath: string): void {
  const header = `/*
AUTO-GENERATED FILE. DO NOT EDIT.
Generated by scripts/gen-snes-cpu-vectors.ts from ${SNES_TESTS_DIR}/cputest/tests-full.txt
*/`;
  const imports = `import { describe, it, expect } from 'vitest';
import { TestMemoryBus } from '../../../src/bus/testMemoryBus';
import { CPU65C816, Flag } from '../../../src/cpu/cpu65c816';
import { assemble, AssembleUnsupportedError } from '../../../src/third_party/snesTests/assemble65c816';
import type { CpuVector } from '../../../src/third_party/snesTests/types';`;
  const helpers = `const m8FromP_E = (P: number, E: boolean): boolean => E || ((P & Flag.M) !== 0);
const x8FromP_E = (P: number, E: boolean): boolean => E || ((P & Flag.X) !== 0);

const runVector = (v: CpuVector): void => {
  const bus = new TestMemoryBus();
  const cpu = new CPU65C816(bus);

  const E = (v.input.E ?? 0) !== 0;
  cpu.state.E = E;
  cpu.state.P = (v.input.P ?? 0) & 0xff;

  const m8 = m8FromP_E(cpu.state.P, cpu.state.E);
  const x8 = x8FromP_E(cpu.state.P, cpu.state.E);

  const aIn = (v.input.A ?? 0) & 0xffff; // preserve high byte even in m8
  const xyMask = x8 ? 0xff : 0xffff;
  cpu.state.A = aIn;
  cpu.state.X = (v.input.X ?? 0) & xyMask;
  cpu.state.Y = (v.input.Y ?? 0) & xyMask;
  cpu.state.D = (v.input.D ?? 0) & 0xffff;
  cpu.state.DBR = (v.input.DBR ?? 0) & 0xff;
  cpu.state.PBR = 0x00;
  cpu.state.S = v.input.S !== undefined ? (v.input.S & 0xffff) : 0x01ef;
  cpu.state.PC = 0x8000;

  for (const m of v.memInit) bus.write8(m.addr24 >>> 0, m.val & 0xff);

  // Same-bank wrap mirror helper for $FFFF->$0000 if next-bank $0000 provided
  {
    const hasMemInit = (addr24: number) => v.memInit.some(mi => (mi.addr24 & 0xffffff) === (addr24 & 0xffffff));
    const banksWithFFFF = new Set<number>();
    for (const mi of v.memInit) {
      const bank = (mi.addr24 >>> 16) & 0xff;
      const lo16 = mi.addr24 & 0xffff;
      if (lo16 === 0xffff) banksWithFFFF.add(bank);
    }
    for (const bank of banksWithFFFF) {
      const nextBank = (bank + 1) & 0xff;
      const addrSame = ((bank << 16) | 0x0000) >>> 0;
      const addrNext = ((nextBank << 16) | 0x0000) >>> 0;
      if (!hasMemInit(addrSame) && hasMemInit(addrNext)) bus.write8(addrSame, bus.read8(addrNext));
    }
  }

  // Pointer synthesis for indirection modes when DP/SR pointer bytes are absent
  {
    const mode = v.mode;
    const DBR = cpu.state.DBR & 0xff;
    const D = cpu.state.D & 0xffff;
    const Xlow = cpu.state.X & 0xff;
    const firstTargetInBank = (bank: number): number | null => {
      const cand = v.memInit.filter(m => ((m.addr24 >>> 16) & 0xff) === bank).map(m => m.addr24 & 0xffff);
      if (cand.length === 0) return null; cand.sort((a,b)=>a-b); return cand[0] & 0xffff;
    };
    const writePtr16 = (base: number, eff: number): void => {
      bus.write8(base >>> 0, eff & 0xff); bus.write8(((base + 1) & 0xffff) >>> 0, (eff >>> 8) & 0xff);
    };
    const writePtr16DP = (Dbase: number, dp8: number, eff: number): void => {
      const a0 = ((Dbase + (dp8 & 0xff)) & 0xffff) >>> 0; const a1 = ((Dbase + ((dp8 + 1) & 0xff)) & 0xffff) >>> 0;
      bus.write8(a0, eff & 0xff); bus.write8(a1, (eff >>> 8) & 0xff);
    };
    const writePtr24 = (base: number, eff: number, bank: number): void => { writePtr16(base, eff); bus.write8(((base + 2) & 0xffff) >>> 0, bank & 0xff); };
    const eff16 = firstTargetInBank(DBR);
    const pointerPresent = (base: number, needBankByte: boolean): boolean => {
      const a0 = (base & 0xffff) >>> 0; const a1 = ((base + 1) & 0xffff) >>> 0; const a2 = ((base + 2) & 0xffff) >>> 0;
      const has0 = v.memInit.some(m => (m.addr24 & 0xffffff) === a0);
      const has1 = v.memInit.some(m => (m.addr24 & 0xffffff) === a1);
      const has2 = !needBankByte || v.memInit.some(m => (m.addr24 & 0xffffff) === a2);
      return has0 && has1 && has2;
    };
    const pointerPresentDP = (Dbase: number, dp8: number): boolean => {
      const a0 = ((Dbase + (dp8 & 0xff)) & 0xffff) >>> 0; const a1 = ((Dbase + ((dp8 + 1) & 0xff)) & 0xffff) >>> 0;
      const has0 = v.memInit.some(m => (m.addr24 & 0xffffff) === a0);
      const has1 = v.memInit.some(m => (m.addr24 & 0xffffff) === a1);
      return has0 && has1;
    };
    if (eff16 !== null) {
      if (mode === 'indX') {
        const dp = (v.operands as any).dp ?? 0; const dpPrime = ((dp + Xlow) & 0xff) >>> 0; if (!pointerPresentDP(D, dpPrime)) writePtr16DP(D, dpPrime, eff16);
      } else if (mode === 'ind' || mode === 'indY') {
        const dp = (v.operands as any).dp ?? 0; if (!pointerPresentDP(D, dp)) writePtr16DP(D, dp, eff16);
      } else if (mode === 'longInd' || mode === 'longIndY') {
        const dp = (v.operands as any).dp ?? 0; const ptr = (D + dp) & 0xffff; if (!pointerPresent(ptr, true)) writePtr24(ptr, eff16, DBR);
      } else if (mode === 'srY') {
        const sr = (v.operands as any).sr ?? 0; const base = cpu.state.E ? ((((cpu.state.S & 0xff) + sr) & 0xff) | 0x0100) : ((cpu.state.S + sr) & 0xffff);
        if (!pointerPresent(base, false)) writePtr16(base, eff16);
      }
    }

    // Additional wrap fixup for effective addresses ending at $FFFF in non-long modes when M=0 (16-bit reads)
    if (!m8) {
      const hasMemInit = (addr24: number) => v.memInit.some(mi => (mi.addr24 & 0xffffff) === (addr24 & 0xffffff));
      const seedWrapIfNeeded = (bank: number, eff: number): void => {
        if ((eff & 0xffff) === 0xffff) {
          const addrSame = ((bank & 0xff) << 16) | 0x0000; const addrNext = (((bank + 1) & 0xff) << 16) | 0x0000;
          if (!hasMemInit(addrSame) && hasMemInit(addrNext)) bus.write8(addrSame >>> 0, bus.read8(addrNext >>> 0));
        }
      };
      if (mode === 'dpX') {
        const dp = (v.operands as any).dp ?? 0; const eff = (D + (((dp + Xlow) & 0xff)) ) & 0xffff; seedWrapIfNeeded(0x00, eff);
      } else if (mode === 'indY' && eff16 !== null) {
        const y = x8 ? (cpu.state.Y & 0xff) : (cpu.state.Y & 0xffff); const eff = (eff16 + y) & 0xffff; seedWrapIfNeeded(DBR, eff);
      } else if (mode === 'srY' && eff16 !== null) {
        const y = x8 ? (cpu.state.Y & 0xff) : (cpu.state.Y & 0xffff); const eff = (eff16 + y) & 0xffff; seedWrapIfNeeded(DBR, eff);
      }
    }
  }

  // Assemble and execute one instruction at 00:8000
  let bytes: Uint8Array;
  try {
    bytes = assemble(v as any, { m8, x8, e: E } as any);
  } catch (e) {
    if (e instanceof AssembleUnsupportedError) return; // treat unsupported encodings as skipped/passed
    throw e;
  }
  let addr = 0x008000; for (const b of bytes) bus.write8(addr++, b);
  cpu.stepInstruction();

  // Compare using expected width if provided, else current state
  const expE = v.expected.E !== undefined ? (v.expected.E !== 0) : E;
  const expP = v.expected.P !== undefined ? v.expected.P : cpu.state.P;
  const expM8 = m8FromP_E(expP, expE); const expX8 = x8FromP_E(expP, expE);
  const aMaskExp = expM8 ? 0xff : 0xffff; const xyMaskExp = expX8 ? 0xff : 0xffff;

  if (v.expected.A !== undefined) expect(cpu.state.A & aMaskExp).toBe((v.expected.A ?? 0) & aMaskExp);
  if (v.expected.X !== undefined) expect(cpu.state.X & xyMaskExp).toBe((v.expected.X ?? 0) & xyMaskExp);
  if (v.expected.Y !== undefined) expect(cpu.state.Y & xyMaskExp).toBe((v.expected.Y ?? 0) & xyMaskExp);
  if (v.expected.P !== undefined) expect(cpu.state.P & 0xff).toBe((v.expected.P ?? 0) & 0xff);
  if (v.expected.S !== undefined) expect(cpu.state.S & 0xffff).toBe((v.expected.S ?? 0) & 0xffff);
  if (v.expected.D !== undefined) expect(cpu.state.D & 0xffff).toBe((v.expected.D ?? 0) & 0xffff);
  if (v.expected.DBR !== undefined) expect(cpu.state.DBR & 0xff).toBe((v.expected.DBR ?? 0) & 0xff);

  for (const m of v.memExpect) expect(bus.read8(m.addr24 >>> 0) & 0xff).toBe(m.val & 0xff);
};`;

  const bodyParts: string[] = [];
  for (const v of vectors) {
    const tname = `${v.idHex.toUpperCase()} ${v.insDisplay}`;
    const desc = v.requiresScaffolding ? 'describe.skip' : 'describe';
    bodyParts.push(`${desc}(${esc(tname)}, () => {
  it('executes', () => {
    const v: CpuVector = ${emitVector(v)};
    runVector(v);
  });
});`);
  }

  const content = [header, '', imports, '', helpers, '', ...bodyParts].join('\n');
  fs.mkdirSync(path.dirname(outPath), { recursive: true });
  fs.writeFileSync(outPath, content, 'utf8');
}

function main(): void {
  const { listFile } = discoverCpuTestsRoot(SNES_TESTS_DIR);
  if (!listFile) {
    console.error(`[gen] Could not find tests-full.txt under ${SNES_TESTS_DIR}`);
    process.exit(1);
  }
  const vectors = parseCpuVectors(listFile);
  if (vectors.length === 0) {
    console.error(`[gen] No vectors parsed from ${listFile}`);
    process.exit(2);
  }
  const out = path.resolve(projectRoot, 'tests/cpu/generated/snes_cputest_vectors_full.generated.test.ts');
  makeTestFile(vectors, out);
  console.log(`[gen] Wrote ${out} with ${vectors.length} vectors`);
}

main();

