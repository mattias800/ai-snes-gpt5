import * as fs from 'fs';
import * as path from 'path';
import { parseSpcVectors, type SpcVector } from '../src/third_party/snesTests/parseSpcVectors';

const projectRoot = path.resolve('.');
const DEFAULT_ROOT = path.resolve(projectRoot, 'test-roms/snes-tests');
const SNES_TESTS_DIR = process.env.SNES_TESTS_DIR || DEFAULT_ROOT;

const esc = (s: string): string => JSON.stringify(s);

const emitMem = (arr: { addr: number; val: number }[]): string => {
  if (arr.length === 0) return '[]';
  return `[
${arr.map(m => `  { addr: ${m.addr >>> 0}, val: ${m.val & 0xff} }`).join(',\n')}
]`;
};

const emitVector = (v: SpcVector): string => {
  const parts: string[] = [
    `idHex: ${esc(v.idHex)}`,
    `insText: ${esc(v.insText)}`,
    `input: { A: ${v.input.A & 0xff}, X: ${v.input.X & 0xff}, Y: ${v.input.Y & 0xff}, P: ${v.input.P & 0xff}${v.input.SP !== undefined ? `, SP: ${v.input.SP & 0xff}` : ''} }`,
    `expected: {${['A','X','Y','P','SP'].filter(k => (v.expected as any)[k] !== undefined).map(k => ` ${k}: ${(v.expected as any)[k] & 0xff}`).join(',')} }`,
    `memInit: ${emitMem(v.memInit)}`,
    `memExpect: ${emitMem(v.memExpect)}`
  ];
  return `{
  ${parts.join(',\n  ')}
}`;
};

const makeTestFile = (vectors: SpcVector[], outPath: string): void => {
  const header = `/*
AUTO-GENERATED FILE. DO NOT EDIT.
Generated by scripts/gen-snes-spc-vectors.ts from ${SNES_TESTS_DIR}/spctest/tests.txt
*/`;
  const imports = `import { describe, it, expect } from 'vitest';
import { APUDevice } from '../../../src/apu/apu';
import { assembleOne, AssembleUnsupportedError } from '../../../src/third_party/snesTests/assembleSpc700';
import type { SpcVector } from '../../../src/third_party/snesTests/parseSpcVectors';`;
  const helpers = `const runVector = (v: SpcVector): void => {
  const apu: any = new APUDevice();
  // Initialize registers
  apu.smp.A = v.input.A & 0xff;
  apu.smp.X = v.input.X & 0xff;
  apu.smp.Y = v.input.Y & 0xff;
  apu.smp.PSW = v.input.P & 0xff;
  // Derive SP for RETI if not specified by input from stack mem inits (so that pop order matches)
  const isReti = /^(ret1|reti)\\b/i.test(v.insText);
  let spEff = v.input.SP !== undefined ? (v.input.SP & 0xff) : 0xef;
  if (isReti && v.input.SP === undefined) {
    const stackInits = v.memInit.filter(m => (m.addr & 0xff00) === 0x0100).slice();
    if (stackInits.length > 0) {
      stackInits.sort((a,b) => a.addr - b.addr);
      const pswAddr = stackInits[0].addr & 0xff;
      spEff = (pswAddr - 1) & 0xff;
    }
  }
  apu.smp.SP = spEff;
  apu.smp.PC = 0x0200;

  // Memory init
  for (const m of v.memInit) apu.write8(m.addr & 0xffff, m.val & 0xff);

  // Assemble instruction at 0x0200
  let bytes: Uint8Array;
  try {
    bytes = assembleOne(v.insText);
  } catch (e) {
    if (e instanceof AssembleUnsupportedError) return; // treat unsupported as skipped
    throw e;
  }
  for (let i = 0; i < bytes.length; i++) apu.aram[(0x0200 + i) & 0xffff] = bytes[i] & 0xff;

  // Pre-prime stack for ret1/reti since we don't run the harness around it
  const expP = (v.expected.P ?? v.input.P) & 0xff;
  if (/^(ret1|reti)\\b/i.test(v.insText)) {
    const sp = apu.smp.SP & 0xff;
    const addr = 0x0100 | ((sp + 1) & 0xff);
    apu.aram[addr] = expP;
  }

  // Execute instruction(s): for RETI variants run exactly one, else allow a small budget
  if (isReti) apu.smp.stepInstruction();
  else apu.step(256);

  const expA = v.expected.A ?? v.input.A;
  const expX = v.expected.X ?? v.input.X;
  const expY = v.expected.Y ?? v.input.Y;

  expect(apu.smp.A & 0xff).toBe(expA & 0xff);
  expect(apu.smp.X & 0xff).toBe(expX & 0xff);
  expect(apu.smp.Y & 0xff).toBe(expY & 0xff);
  expect(apu.smp.PSW & 0xff).toBe(expP & 0xff);

  for (const m of v.memExpect) {
    const actual = apu.read8(m.addr & 0xffff) & 0xff;
    expect(actual).toBe(m.val & 0xff);
  }
};`;

  const body: string[] = [];
  for (const v of vectors) {
    const name = `${v.idHex.toUpperCase()} ${v.insText}`;
    body.push(`describe(${esc(name)}, () => { it('executes', () => { const v: SpcVector = ${emitVector(v)}; runVector(v); }); });`);
  }
  const content = [header, '', imports, '', helpers, '', ...body].join('\n');
  fs.mkdirSync(path.dirname(outPath), { recursive: true });
  fs.writeFileSync(outPath, content, 'utf8');
};

const main = (): void => {
  const list = path.resolve(SNES_TESTS_DIR, 'spctest', 'tests.txt');
  if (!fs.existsSync(list)) {
    console.error(`[gen] Missing ${list}`);
    process.exit(1);
  }
  const limit = Number(process.env.SPC_VECTORS_GEN_LIMIT || '0');
  const vectors = parseSpcVectors(list, { limit: limit > 0 ? limit : undefined });
  if (vectors.length === 0) {
    console.error('[gen] No SPC vectors parsed');
    process.exit(2);
  }
  const out = path.resolve(projectRoot, 'tests/apu/generated/spc700_vectors.generated.test.ts');
  makeTestFile(vectors, out);
  console.log(`[gen] Wrote ${out} with ${vectors.length} vectors`);
};

main();
